# Summary of the commands in this Tutorial:

````
Exercises in LInux:

Where are the binaries of terminator installed?

The binaries of terminator can be found in the /bin folder 

Use the program od to make it more readable od -N10 -t d1 /dev/urandom

od: Used to dump binary data

-N10: This option tells od to read only 10 bytes from the input. The N option specifies the number of bytes to be read and displayed.

-t d1: This option specifies the output format. The -t option is used to specify the type of data to be displayed.

d means "signed decimal"
1 specifies the number of bytes per integer (i.e., d1 implies a 1-byte signed integer in decimal format).
/dev/urandom: This is the input file. /dev/urandom is a pseudo-random number generator provided by the system. It generates random data that can be read by applications.

In summary, this command will read 10 bytes of random data from /dev/urandom and display them in a signed decimal format using 1 byte per integer.

What useful information is in /proc?

Process information Pseudo Filesystem.

Proc contains information about filesystems, different mounts, networks, memory information and so on.

The following files are writable by the user: 

/mtrr

/sysrq-trigger

Compiler, Make and CMake

#include <stdio.h>
int main(void) {
printf(„Hello, MSE!\n“);
return 0;
}

This can be compiled with:

// Compile and name with -o
gcc hello.c ‐o hello

// This can be executed:
./hello
/home/graf/projects/task1/hello

There always two stages in compiling:
First stage is compilation into a object module. The second stage is Linking. We chuck them togheter. This may be due to option calls that need to be linked togheter. A big project may have hundreds or thousand of files. A library for example are just some object files. This process can be done togheter (Make/Buils)


gcc -c compiles the code and gcc calls the linker. We can also first create the assembly code by using gcc -S.

Header File

The left part represents the preprocessing, while the right side is the linking.
An error could be:

# Linking Error
/usr/bin/ld: /tmp/ccRU8X1A.o: in function `main':
main.c:(.text+0x11): undefined reference to `calculate'
collect2: error: ld returned 1 exit status

/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o: in function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

# Other issues may include multiple definitions of main:
/usr/bin/ld: /tmp/ccWVcfz3.o: in function `main':
main.c:(.text+0x0): multiple definition of `main'; /tmp/ccF9Glu4.o:calculate.c:(.text+0x14): first
defined here
collect2: error: ld returned 1 exit status



What does the c processor do?

The preprocessor takes the header files (This is just the signature) and replaces it with the actual information of the header file. The linker then combines everything by taking the code of the corresponding file to link everything togheter. 

Exercises:

Create a hello world program hello.c

Which files get created? What are the attributes of these files? What is

the name of the executable? Execute the program.

$ gcc -S -g hello.c -o hello.s to debug

The primary file created is a.out, which is the default output executable file generated by GCC when no output file name is specified using the -o option. The attributes of a.out are dependent on the system, but it will have the execute permission set. The name of the executable is a.out. To execute the program, you would run ./a.out in the terminal.  

-rwxrwxr-x

One file is created called a.out and of course we have hello.c

To change the output

gcc hello.c ‐o hello
// Execute
./hello

It defines everything of the function very precisely.

gcc main.c calculate.c -o test
./test

GNU Make: 

Is a build Management Tool. Its interprets a file called Makefile. Just type make to do this. 

prog: prog.c prog.h
  gcc ‐o prog prog.c

CC = /usr/bin/gcc
CFLAGS = -Wall -g
LDFLAGS = ‐lm –lpthread
EXEC_NAME = lol
OBJ = main.o calculate.o

all: $(OBJ)
	$(CC) $(CFLAGS) -o $(EXEC_NAME) $(OBJ)

%.o: %.c
	$(CC) $(CFLAGS) -c $<

clean:
	rm -f $(OBJ) $(EXEC_NAME)


CC = /usr/bin/gcc
CFLAGS = -Wall -g
LDFLAGS = -lm -lpthread
SRC = main.c calculate.c
EXEC_NAME = test
DEPENDFILE = .depend
# Compile and Assemble C Source Files into Object Files
OBJ = $(SRC:.c=.o)

# Create dependencies to make sure the modules are rebuilt after modification.
$(DEPENDFILE): $(SRC)
	@echo Create dependencies...
	$(CC) -MM $(SRC) > $(DEPENDFILE)

# This target creates the executable from all the given object files.
all: $(DEPENDFILE) $(OBJ)
	$(CC) $(CFLAGS) -o $(EXEC_NAME) $(OBJ) $(LDFLAGS)

# This target removes all generated files from the system.
clean:
	@echo Remove generated files...
	rm -f $(EXEC_NAME) $(OBJ) $(DEPENDFILE)

-include $(DEPENDFILE)

CMake

Cross plattform Make. It creates a make file and you run make to create the project. 

 Static and Dynamic Libraries:

Static libraries are self contained in the application. In dynamic libraries they need to be shipped seperate and just have a reference. This is the case with very large libraries. Here it makes sense to use dynamic libraries. 

Static linking: All necessairy libraries get linked at link time

In dynamic linking, for every function that is located in the code a stub is inserted. These are then replaced.

Use Case 1: Library to read sensor → Here static linking would be sensefull, when the library is small.

Git 

Git exercises 

# Get git:
sudo apt-get update && sudo apt-get install git

# Get the current version:
git --version

# Configure git:
git config --global user.name John Doe
git config --global user.email john.doe@ost.ch
git config --global core.editor nanogit --version

# Initalise a git repo: (.git) is created
git init

# Check the status:
git status 

# Add files: (Changes to be commited)
git add text1.txt

# Add a commit: 
git commit -m "My first commit"
Nothing to commit left

# shows the logs of the commits
git log 

# Show contents at this commit 
git show 3c6c42b3c38e4ba38f5d9de6a229d09d0a982155:text1.txt

# Show differences in files:
git diff 7879b233cfcffed19d5c874b8670cccb31e53ca5 6aaba06df0990bb79cf0ead11e0367215778e2df
git diff 7879b233cfcffed19d5c874b8670cccb31e53ca5 6aaba06df0990bb79cf0ead11e0367215778e2df

# Going to the latest commit
git checkout master

# Going to a previous commit state
git checkout 3c6c42b3c38e4ba38f5d9de6a229d09d0a982155

## Branching 

# Creating a branch and switching to this branch (-b = new branch)
git checkout -b test
git checkout master

# Show all branches:
git branch

# Show the log
git log --all --decorate --oneline --graph

# Merging:
git checkout master
git merge test


```